// Generated by CoffeeScript 1.8.0
(function() {
  var Connection, debug, defer, net, pubsub,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  debug = require('debug')('xbmc:TCPConnection');

  pubsub = require('./PubSub');

  defer = require('node-promise').defer;

  net = require('net');

  Connection = (function() {
    function Connection(options) {
      var _base, _base1, _base2, _base3, _base4, _base5, _base6;
      this.options = options != null ? options : {};
      this.onMessage = __bind(this.onMessage, this);
      this.parseBuffer = __bind(this.parseBuffer, this);
      this.onClose = __bind(this.onClose, this);
      this.onTimeout = __bind(this.onTimeout, this);
      this.onError = __bind(this.onError, this);
      this.onOpen = __bind(this.onOpen, this);
      this.publish = __bind(this.publish, this);
      this.close = __bind(this.close, this);
      this.send = __bind(this.send, this);
      this.isActive = __bind(this.isActive, this);
      this.create = __bind(this.create, this);
      debug('constructor', this.options);
      if ((_base = this.options).port == null) {
        _base.port = 9090;
      }
      if ((_base1 = this.options).host == null) {
        _base1.host = '127.0.0.1';
      }
      if ((_base2 = this.options).user == null) {
        _base2.user = 'xbmc';
      }
      if ((_base3 = this.options).password == null) {
        _base3.password = false;
      }
      if ((_base4 = this.options).verbose == null) {
        _base4.verbose = false;
      }
      if ((_base5 = this.options).connectNow == null) {
        _base5.connectNow = true;
      }
      if ((_base6 = this.options).timeout == null) {
        _base6.timeout = 0;
      }
      this.readRaw = '';
      this.sendQueue = [];
      this.deferreds = {};
      if (this.options.connectNow) {
        this.create();
      }
    }

    Connection.prototype.create = function() {
      debug('create');
      this.socket = net.connect({
        host: this.options.host,
        port: this.options.port
      });
      this.socket.on('connect', this.onOpen);
      this.socket.on('data', this.onMessage);
      this.socket.on('end', this.onClose);
      this.socket.on('timeout', this.onTimeout);
      this.socket.on('error', this.onError);
      this.socket.on('close', this.onClose);
      return this.socket.setTimeout(this.options.timeout);
    };

    Connection._id = 0;

    Connection.generateId = function() {
      return "__id" + (++Connection._id);
    };

    Connection.prototype.isActive = function() {
      var _ref;
      debug('isActive');
      return ((_ref = this.socket) != null ? _ref._connecting : void 0) === false;
    };

    Connection.prototype.send = function(data) {
      var dfd, _base, _name;
      if (data == null) {
        data = null;
      }
      debug('send', JSON.stringify(data));
      if (!data) {
        throw new Error('Connection: Unknown arguments');
      }
      if (data.id == null) {
        data.id = Connection.generateId();
      }
      dfd = (_base = this.deferreds)[_name = data.id] != null ? _base[_name] : _base[_name] = defer();
      if (!this.isActive()) {
        this.sendQueue.push(data);
      } else {
        data.jsonrpc = '2.0';
        data = JSON.stringify(data);
        this.publish('send', data);
        this.socket.write(data);
      }
      return dfd.promise;
    };

    Connection.prototype.close = function(fn) {
      var err;
      if (fn == null) {
        fn = null;
      }
      debug('close');
      try {
        this.socket.end();
        this.socket.destroy();
        if (fn) {
          return fn();
        }
      } catch (_error) {
        err = _error;
        this.publish('error', err);
        if (fn) {
          return fn(err);
        }
      }
    };

    Connection.prototype.publish = function(topic, data) {
      var dataVerbose;
      if (data == null) {
        data = {};
      }
      dataVerbose = typeof data === 'object' ? JSON.stringify(data) : data;
      debug('publish', topic, dataVerbose);
      return pubsub.emit("connection:" + topic, data);
    };

    Connection.prototype.onOpen = function() {
      debug('onOpen');
      this.publish('open');
      return setTimeout(((function(_this) {
        return function() {
          var item, _i, _len, _ref;
          _ref = _this.sendQueue;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            item = _ref[_i];
            _this.send(item);
          }
          return _this.sendQueue = [];
        };
      })(this)), 500);
    };

    Connection.prototype.onError = function(evt) {
      debug('onError', JSON.stringify(evt));
      return this.publish('error', evt);
    };

    Connection.prototype.onTimeout = function(evt) {
      debug('onTimeout', JSON.stringify(evt));
      return this.publish('timeout', evt);
    };

    Connection.prototype.onClose = function(evt) {
      debug('onClose', evt);
      return this.publish('close', evt);
    };

    Connection.prototype.parseBuffer = function(buffer) {
      var err, line, lines, rawline, rawlines, splitStr, str, _i, _len;
      debug('parseBuffer');
      this.readRaw = buffer.toString();
      lines = [];
      try {
        line = JSON.parse(this.readRaw);
        lines.push(line);
        this.readRaw = '';
      } catch (_error) {
        err = _error;
        splitStr = '{"jsonrpc":"2.0"';
        rawlines = this.readRaw.split(splitStr);
        lines = [];
        for (_i = 0, _len = rawlines.length; _i < _len; _i++) {
          rawline = rawlines[_i];
          if (!rawline.length) {
            continue;
          }
          str = splitStr + rawline;
          try {
            this.readRaw.replace(/}{/g, '}%%%%{').split(/%%%%/).forEach(function(part) {
              return lines.push(JSON.parse(part));
            });
          } catch (_error) {}
        }
      }
      return lines;
    };

    Connection.prototype.onMessage = function(buffer) {
      var dfd, evt, id, line, lines, _i, _len, _ref, _ref1, _results;
      debug('onMessage');
      lines = this.parseBuffer(buffer);
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        evt = {};
        evt.data = line;
        id = (_ref = evt.data) != null ? _ref.id : void 0;
        dfd = this.deferreds[id];
        delete this.deferreds[id];
        if (evt.data.error) {
          this.onError(evt);
          if (dfd) {
            dfd.reject(evt.data);
          }
          continue;
        }
        this.publish('data', evt.data);
        if ((_ref1 = evt.data.method) != null ? _ref1.indexOf('.On' > 1) : void 0) {
          this.publish('notification', evt.data);
        }
        if (dfd) {
          _results.push(dfd.resolve(evt.data));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Connection;

  })();

  module.exports = Connection;

}).call(this);
